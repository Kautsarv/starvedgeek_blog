[ { "title": "[Selenium] Simple Java Automation Script", "url": "/posts/simple-selenium-java-automation-script/", "categories": "Front End Testing, Selenium", "tags": "Learning", "date": "2022-06-26 16:24:00 +0800", "snippet": "For learning purpose!!This article will show an example about how to create simple automation script using Selenium with Java language.Prerequisites Install Java JDK Install IDE, usually i’m using Intellij IDE Download Selenium Java Clients Driver Download Webdriver depends in which browser we want to test, the most famous one is ChromeDriver (Note: ChromeDriver version should be same as the currently used Chrome version)InstallationStep 1 : Create new Java project in IntellijStep 2 : Add the downloaded selenium JAR into Intellij as external librariesSelect all JAR files and libs folderStep 3 : Create webdriver directory inside project and put the downloaded Chromedriver into the folderImplementationNow we will create some simple automation script using dummy website that i recommend for learning create automation script katalon-demo-cura.herokuapp.com. First, we need to create new Java class inside src directory.The scenario is to verify user successfully make an appointment, here is the complete source codeimport org.openqa.selenium.By;import org.openqa.selenium.WebElement;import org.openqa.selenium.chrome.ChromeDriver;import org.openqa.selenium.support.ui.Select;import java.util.List;import java.util.concurrent.ThreadLocalRandom;public class simpleSeleniumTest { public static void main(String[] args){ //Create Chromedriver Object System.setProperty(\"webdriver.chrome.driver\",\"./webdriver/chromedriver\"); //Set path to Chromedriver manually ChromeDriver driver = new ChromeDriver(); //instantiate Chromedriver //Open Browser and enter the URL driver.get(\"https://katalon-demo-cura.herokuapp.com/\"); //Assert website title header with expected title String title = driver.getTitle(); //Get website title String expectedtitle = \"CURA Healthcare Service\"; //Expected title if (title.contentEquals(expectedtitle)) { //Create condition for checking whether title already correct or not System.out.println(\"Title Match!\"); } else { System.out.println(\"Title Doesn't Match\"); } //User click the Appointment button WebElement buttonAppointment = driver.findElement(By.id(\"btn-make-appointment\")); //Create Appointment button object with ID buttonAppointment.click(); //Click Appointment button //Verify login page is displayed String loginURL = driver.getCurrentUrl(); //Get the current URL if (loginURL.equals(\"https://katalon-demo-cura.herokuapp.com/profile.php#login\")) { //Create condition for checking whether Login URL already correct or not System.out.println(\"Login URL correct!\"); } else { System.out.println(\"Incorrect Login URL!\"); } WebElement labelLogin = driver.findElement(By.xpath(\"//*[@id='login']/div/div/div[1]/h2\")); //Create Login label object with XPATH String loginText = labelLogin.getText(); //Get login label text if (loginText.equals(\"Login\")) { //Create condition for checking whether Login text already correct or not System.out.println(\"Login Page Opened!\"); } else { System.out.println(\"Login Page Not Found!\"); } //User login with username and password WebElement inputUsername = driver.findElement(By.id(\"txt-username\")); //Create Username input field object by ID inputUsername.sendKeys(\"John Doe\"); //Input text into Username field WebElement inputPassword = driver.findElement(By.id(\"txt-password\")); //Create Password input field object by ID inputPassword.sendKeys(\"ThisIsNotAPassword\"); //Input text into Password field WebElement buttonLogin = driver.findElement(By.id(\"btn-login\")); //Create Login button object by ID buttonLogin.click(); //Click Login button //Verify appointment page is displayed String appointmentURL = driver.getCurrentUrl(); //Get the current URL if (appointmentURL.equals(\"https://katalon-demo-cura.herokuapp.com/#appointment\")) { //Create condition for checking whether appointment URL already correct or not System.out.println(\"Appointment URL correct!\"); } else { System.out.println(\"Incorrect Appointment URL!\"); } WebElement labelAppointment = driver.findElement(By.xpath(\"//*[@id='appointment']/div/div/div/h2\")); //Create Appointment label object with XPATH String appointmentText = labelAppointment.getText(); //Get Appointment label text if (appointmentText.equals(\"Make Appointment\")) { //Create condition for checking whether Appointment text already correct or not System.out.println(\"Appointment Page Opened!\"); } else { System.out.println(\"Appointment Page Not Found!\"); } //User select facility droplist Select drpFacility = new Select(driver.findElement(By.id(\"combo_facility\"))); //Create Facility droplist object by ID drpFacility.selectByValue(\"Hongkong CURA Healthcare Center\"); //Select Facility droplist by value String selectedValue = drpFacility.getWrappedElement().getDomProperty(\"value\"); //Get the selected droplist value based on DOM property //User checklist hospital readmission checkbox WebElement chkAdmission = driver.findElement(By.id(\"chk_hospotal_readmission\")); //Create Readmission checkbox object by ID chkAdmission.click(); //Click Readmission checkbox String chkAdmissionFlag; //Create Admission flag variable if(chkAdmission.isSelected()){ //Get the checkbox checked state based on DOM property chkAdmissionFlag = \"Yes\"; } else{ chkAdmissionFlag = \"No\"; } //User select healthcare program radiobutton WebElement radioMedicaid = driver.findElement(By.id(\"radio_program_medicaid\")); //Create Healthcare Program radiobutton object by ID radioMedicaid.click(); //Click Healthcare Program radiobutton String radioMedicaidText = radioMedicaid.getDomProperty(\"value\"); //Get the radiobutton value based on DOM property //User select visit date WebElement buttonCalendar = driver.findElement(By.id(\"txt_visit_date\")); //Create Visit Calendar button object by ID buttonCalendar.click(); //Click Visit Calendar List&lt;WebElement&gt; date = driver.findElements(By.xpath(\"//td[@class='day']\")); //Create element lists of date object to get the maximum date on a month int randomDate = ThreadLocalRandom.current().nextInt(1, date.size() + 1); //Create variable for input random date between 1-maximum date in a month WebElement selectDate = driver.findElement(By.xpath(\"//td[@class='day' and normalize-space(text())='\"+randomDate+\"']\")); //Create date object based on inputted number in variable randomDate selectDate.click(); //Click date String selectedDate = buttonCalendar.getDomProperty(\"value\"); //Get the date value based on DOM property //User input comment WebElement inputComment = driver.findElement(By.id(\"txt_comment\")); //Create Comment input object by ID inputComment.sendKeys(\"Test Selenium\"); //Input text into Comment field String inputtedComment = inputComment.getDomProperty(\"value\"); //Get the inputted Comment value based on DOM property //User submit appointment WebElement buttonBook = driver.findElement(By.id(\"btn-book-appointment\")); //Create Appointment button object by ID buttonBook.click(); //Click Appointment button //Verify appointment confirmation page displayed String appointmentConfirmationURL = driver.getCurrentUrl(); //Get the current URL if (appointmentConfirmationURL.equals(\"https://katalon-demo-cura.herokuapp.com/appointment.php#summary\")) { //Create condition for checking whether appointment confirmation URL already correct or not System.out.println(\"Appointment Confirmation URL correct!\"); } else { System.out.println(\"Incorrect Appointment Confirmation URL!\"); } WebElement labelConfirmation = driver.findElement(By.xpath(\"//*[@id='summary']/div/div/div[1]/h2\")); //Create Appointment Confirmation label object with XPATH String confirmationText = labelConfirmation.getText(); //Get Appointment Confirmation label text if (confirmationText.equals(\"Appointment Confirmation\")) { //Create condition for checking whether Appointment Confirmation text already correct or not System.out.println(\"Appointment Confirmation Opened!\"); } else { System.out.println(\"Appointment Confirmation Not Found!\"); } //Assert appointment confirmation data with expected result based on inputted data on previous page WebElement labelFacility = driver.findElement(By.id(\"facility\")); //Create Facility text object with ID WebElement labelReadmission = driver.findElement(By.id(\"hospital_readmission\")); //Create Readmission text object with ID WebElement labelProgram = driver.findElement(By.id(\"program\")); //Create Healthcare Program text object with ID WebElement labelVisitDate = driver.findElement(By.id(\"visit_date\")); //Create Visit Date text object with ID WebElement labelComment = driver.findElement(By.id(\"comment\")); //Create Comment text object with ID System.out.println(\"Facility : \"+selectedValue); System.out.println(\"Hospital Readmission : \"+chkAdmissionFlag); System.out.println(\"Healthcare Program : \"+radioMedicaidText); System.out.println(\"Visit Date : \"+selectedDate); System.out.println(\"Comment : \"+inputtedComment); if (labelFacility.getText().equals(selectedValue) //Create condition for checking whether all displayed fields are identics with the inputted data &amp;&amp; labelReadmission.getText().equals(chkAdmissionFlag) &amp;&amp; labelProgram.getText().equals(radioMedicaidText) &amp;&amp; labelVisitDate.getText().equals(selectedDate) &amp;&amp; labelComment.getText().equals(inputtedComment)) { System.out.println(\"Test Passed!\"); } else { System.out.println(\"Test Failed!\"); } //Close browser driver.close(); }}Now run the java class to execute the automation script and let the magical robot works for you.Code ExplanationStep 1 : Setting up the ChromeDriver and instantiate the ChromeDriver objectWe need to specify our ChromeDriver path by using System.setProperty(\"webdriver.chrome.driver\",\"PATH_TO_CHROMEDRIVER\"); and also instantiate the ChromeDriver object//Create Chromedriver ObjectSystem.setProperty(\"webdriver.chrome.driver\",\"./webdriver/chromedriver\"); //Set path to Chromedriver manuallyChromeDriver driver = new ChromeDriver(); //instantiate ChromedriverStep 2 : Open the browser and check the browser TitleIn this step we want to open the browser and navigate into the website url by using driver.get(\"WEBSITE_URL\"); after the web opened, we want to get the website title and store it into String variable by using String title = driver.getTitle(); Website TitleThen we will create condition to check whether title already same as the expected title or not//Open Browser and enter the URLdriver.get(\"https://katalon-demo-cura.herokuapp.com/\");//Assert website title header with expected titleString title = driver.getTitle(); //Get website titleString expectedtitle = \"CURA Healthcare Service\"; //Expected titleif (title.contentEquals(expectedtitle)) { //Create condition for checking whether title already correct or not System.out.println(\"Title Match!\");}else { System.out.println(\"Title Doesn't Match\");}Step 3 : User open the login pageUser need to click the Appointment button in the screen to make appointmentWe need to create the Appointment button object so the driver able to click the button, for creating the object we can use this code depends on the suitable locator typeWebElement objectName = driver.findElement(By.id(\"ELEMENT_ID\"));WebElement objectName = driver.findElement(By.xpath(\"ELEMENT_XPATH\"));WebElement objectName = driver.findElement(By.cssSelector(\"ELEMENT_CSS\"));WebElement objectName = driver.findElement(By.linkText(\"ELEMENT_LINKTEXT\"));WebElement objectName = driver.findElement(By.className(\"ELEMENT_CLASSNAME\"));WebElement objectName = driver.findElement(By.name(\"ELEMENT_NAME\"));We can find the object locator by using chrome inspect element (right click on the object and select inspect). Button Appointment has id btn-make-appointment so we can use WebElement buttonAppointment = driver.findElement(By.id(\"btn-make-appointment\")); and to click the button buttonAppointment.click();//User click the Appointment buttonWebElement buttonAppointment = driver.findElement(By.id(\"btn-make-appointment\")); //Create Appointment button object with IDbuttonAppointment.click(); //Click Appointment buttonAfter user click the Appointment button, then login page displayed, we need to verify it. We can store the current opened URL into String variable by using String loginurl = driver.getCurrentUrl(); and then create a condition to check whether the opened URL already same as the expected URL or not. Also we want to verify some object inside the Login page to make sure the page is opened, we can create the Login title header object by using xpath locator WebElement labelLogin = driver.findElement(By.xpath(\"//*[@id='login']/div/div/div[1]/h2\")); Getting XPATH on the objectThen we need to get the text from the object that we already created and store it into a variable, we can use String loginText = labelLogin.getText(); Now we able to create condition to check whether the Login header object text already same as the expected text or not//Verify login page is displayedString loginURL = driver.getCurrentUrl(); //Get the current URLif (loginURL.equals(\"https://katalon-demo-cura.herokuapp.com/profile.php#login\")) { //Create condition for checking whether Login URL already correct or not System.out.println(\"Login URL correct!\");}else { System.out.println(\"Incorrect Login URL!\");}WebElement labelLogin = driver.findElement(By.xpath(\"//*[@id='login']/div/div/div[1]/h2\")); //Create Login label object with XPATHString loginText = labelLogin.getText(); //Get login label textif (loginText.equals(\"Login\")) { //Create condition for checking whether Login text already correct or not System.out.println(\"Login Page Opened!\");}else { System.out.println(\"Login Page Not Found!\");}Step 4 : User successfully loginIn order to login, we need to input Username, Password and click the Login button.First, we need to create the object for Username input field by using WebElement inputUsername = driver.findElement(By.id(\"txt-username\")); and input the username text into the object by using inputUsername.sendKeys(\"John Doe\");Next, we create the object for Password input field by using WebElement inputPassword = driver.findElement(By.id(\"txt-password\")); and input the password text into the object by using inputPassword.sendKeys(\"ThisIsNotAPassword\");\");Now we need to click the Login button, as usual we create the Login button object with WebElement buttonLogin = driver.findElement(By.id(\"btn-login\")); and click the button with buttonLogin.click();//User login with username and passwordWebElement inputUsername = driver.findElement(By.id(\"txt-username\")); //Create Username input field object by IDinputUsername.sendKeys(\"John Doe\"); //Input text into Username fieldWebElement inputPassword = driver.findElement(By.id(\"txt-password\")); //Create Password input field object by IDinputPassword.sendKeys(\"ThisIsNotAPassword\"); //Input text into Password fieldWebElement buttonLogin = driver.findElement(By.id(\"btn-login\")); //Create Login button object by IDbuttonLogin.click(); //Click Login buttonWe need to make sure the user is successfully logged in, to verify it, we can get the currently opened page URL with String appointmenturl = driver.getCurrentUrl(); and then create a condition to check whether the opened URL already correct as expected or not.Also we can verify it by using an object inside the page, we will create an object that contains Make Appointment title label by using WebElement labelAppointment = driver.findElement(By.xpath(\"//*[@id='appointment']/div/div/div/h2\")); and then create a condition to check whether the object text already correct as expected or not.//Verify appointment page is displayedString appointmentURL = driver.getCurrentUrl(); //Get the current URLif (appointmentURL.equals(\"https://katalon-demo-cura.herokuapp.com/#appointment\")) { //Create condition for checking whether appointment URL already correct or not System.out.println(\"Appointment URL correct!\");}else { System.out.println(\"Incorrect Appointment URL!\");}WebElement labelAppointment = driver.findElement(By.xpath(\"//*[@id='appointment']/div/div/div/h2\")); //Create Appointment label object with XPATHString appointmentText = labelAppointment.getText(); //Get Appointment label textif (appointmentText.equals(\"Make Appointment\")) { //Create condition for checking whether Appointment text already correct or not System.out.println(\"Appointment Page Opened!\");}else { System.out.println(\"Appointment Page Not Found!\");}Step 5 : User submit an appointmentIn the Make Appointment page, there are several types of fields, Facility is a droplist, Hospital Readmission is a checkbox, Healthcare Program is a radio button, Visit Date is a calendar, Comment is an input textfield. Each type of fields have different treatment.Let’s start from Facility, Because Facility is a droplist, to create the object we need to use Select instead of WebElement. This is the example Select drpFacility = new Select(driver.findElement(By.id(\"combo_facility\"))); and to select the droplist we can use several options By Value (Value can be found inside the HTML attribute) drpFacility.selectByValue(\"Hongkong CURA Healthcare Center\"); By Droplist Index (Index start from 0) drpFacility.selectByIndex(1); By Visible Text drpFacility.selectByVisibleText(\"Hongkong CURA Healthcare Center\");After droplist is selected, we want to save the selected value and store it into a variable that we will use later in the last step, we will get the DOM property named value by using String selectedValue = drpFacility.getWrappedElement().getDomProperty(\"value\"); we can check the property in browser inspect element and then open Properties tab//User select facility droplistSelect drpFacility = new Select(driver.findElement(By.id(\"combo_facility\"))); //Create Facility droplist object by IDdrpFacility.selectByValue(\"Hongkong CURA Healthcare Center\"); //Select Facility droplist by valueString selectedValue = drpFacility.getWrappedElement().getDomProperty(\"value\"); //Get the selected droplist value based on DOM propertyNext we create checkbox object with WebElement chkAdmission = driver.findElement(By.id(\"chk_hospotal_readmission\")); and click it with chkAdmission.click(); then we can create a condition to check whether the user click the checkbox or not with chkAdmission.isSelected() and we can store the flag into chkAdmissionFlag variable//User checklist hospital readmission checkboxWebElement chkAdmission = driver.findElement(By.id(\"chk_hospotal_readmission\")); //Create Readmission checkbox object by IDchkAdmission.click(); //Click Readmission checkboxString chkAdmissionFlag; //Create Admission flag variableif(chkAdmission.isSelected()){ //Get the checkbox checked state based on DOM property chkAdmissionFlag = \"Yes\";}else{ chkAdmissionFlag = \"No\";}For radiobutton is same like usual, we can use WebElement like this WebElement radioMedicaid = driver.findElement(By.id(\"radio_program_medicaid\")); and then to click the radiobutton we use radioMedicaid.click(); also we want to save the selected radiobutton value and store it into a variable that we will use later in the last step with String radioMedicaidText = radioMedicaid.getDomProperty(\"value\");//User select healthcare program radiobuttonWebElement radioMedicaid = driver.findElement(By.id(\"radio_program_medicaid\")); //Create Healthcare Program radiobutton object by IDradioMedicaid.click(); //Click Healthcare Program radiobuttonString radioMedicaidText = radioMedicaid.getDomProperty(\"value\"); //Get the radiobutton value based on DOM propertyFor Calendar is also same, to create the object we use WebElement like this WebElement buttonCalendar = driver.findElement(By.id(\"txt_visit_date\")); then user need to click the object to open the Calendar pop up buttonCalendar.click(); after the pop up displayed, we want to get all of the displayed date elements and put it into list by using List&lt;WebElement&gt; date = driver.findElements(By.xpath(\"//td[@class='day']\"));Now we can use the created list for determining the maximum date in the current month, we are doing this because each month have different total days between 28-31 days. Then we can create a random number generator that generate number between 1-date.size() this function used to determine total days in selected month, the code looks like this int randomDate = ThreadLocalRandom.current().nextInt(1, date.size() + 1); next we create an object that able to find the date based on previously generated random number by using WebElement selectDate = driver.findElement(By.xpath(\"//td[@class='day' and normalize-space(text())='\"+randomDate+\"']\")); then click the date with selectDate.click(); now we save the selected date value and store it into a variable that we will use later in the last step with String selectedDate = buttonCalendar.getDomProperty(\"value\");//User select visit dateWebElement buttonCalendar = driver.findElement(By.id(\"txt_visit_date\")); //Create Visit Calendar button object by IDbuttonCalendar.click(); //Click Visit CalendarList&lt;WebElement&gt; date = driver.findElements(By.xpath(\"//td[@class='day']\")); //Create element lists of date object to get the maximum date on a monthint randomDate = ThreadLocalRandom.current().nextInt(1, date.size() + 1); //Create variable for input random date between 1-maximum date in a monthWebElement selectDate = driver.findElement(By.xpath(\"//td[@class='day' and normalize-space(text())='\"+randomDate+\"']\")); //Create date object based on inputted number in variable randomDateselectDate.click(); //Click dateString selectedDate = buttonCalendar.getDomProperty(\"value\"); //Get the date value based on DOM propertyFor the Comment field is same like username input field that we already created before, we create the object with WebElement inputComment = driver.findElement(By.id(\"txt_comment\")); and input the text into it inputComment.sendKeys(\"Test Selenium\"); also save the inputted value into a variable String inputtedComment = inputComment.getDomProperty(\"value\");//User input commentWebElement inputComment = driver.findElement(By.id(\"txt_comment\")); //Create Comment input object by IDinputComment.sendKeys(\"Test Selenium\"); //Input text into Comment fieldString inputtedComment = inputComment.getDomProperty(\"value\"); //Get the inputted Comment value based on DOM propertyFinally we can click the booking button, as always we need to create the object first WebElement buttonBook = driver.findElement(By.id(\"btn-book-appointment\")); then we can interact to click the button with buttonBook.click();//User submit appointmentWebElement buttonBook = driver.findElement(By.id(\"btn-book-appointment\")); //Create Appointment button object by IDbuttonBook.click(); Step 6 : User successfully making an appointmentThis will be our last step, after submit an appointment, user will be directed to confirmation page, we need to verify whether confirmation page is displayed correctly or not.We want to verify whether the opened URL already correct or not, we need to get the current URL and store it into a variable with String appointmentConfirmationURL = driver.getCurrentUrl(); then create a condition to check whether the URL already as expected or not. After that we want to verify the Appointment Confirmation title label, so we create an object for the label with WebElement labelConfirmation = driver.findElement(By.xpath(\"//*[@id='summary']/div/div/div[1]/h2\")); and store the label text into a variable with String confirmationText = labelConfirmation.getText(); now we can create a condition to check whether the Appointment Confirmation title text already as expected or not.//Verify appointment confirmation page displayedString appointmentConfirmationURL = driver.getCurrentUrl(); //Get the current URLif (appointmentConfirmationURL.equals(\"https://katalon-demo-cura.herokuapp.com/appointment.php#summary\")) { //Create condition for checking whether appointment confirmation URL already correct or not System.out.println(\"Appointment Confirmation URL correct!\");}else { System.out.println(\"Incorrect Appointment Confirmation URL!\");}WebElement labelConfirmation = driver.findElement(By.xpath(\"//*[@id='summary']/div/div/div[1]/h2\")); //Create Appointment Confirmation label object with XPATHString confirmationText = labelConfirmation.getText(); //Get Appointment Confirmation label textif (confirmationText.equals(\"Appointment Confirmation\")) { //Create condition for checking whether Appointment Confirmation text already correct or not System.out.println(\"Appointment Confirmation Opened!\");}else { System.out.println(\"Appointment Confirmation Not Found!\");}Now we want to assert all of the inputted data on the previous page with the displayed data in the Confirmation Page, first we need to create objects to get the value label on each fields, then we create a condition to compare the text for each fields on the Confirmation page with the variables that we already created on the previous page, if all of the text equals, then we will show Test Passed! in the console, otherwise Test Failed! will displayed.//Assert appointment confirmation data with expected result based on inputted data on previous pageWebElement labelFacility = driver.findElement(By.id(\"facility\")); //Create Facility text object with IDWebElement labelReadmission = driver.findElement(By.id(\"hospital_readmission\")); //Create Readmission text object with IDWebElement labelProgram = driver.findElement(By.id(\"program\")); //Create Healthcare Program text object with IDWebElement labelVisitDate = driver.findElement(By.id(\"visit_date\")); //Create Visit Date text object with IDWebElement labelComment = driver.findElement(By.id(\"comment\")); //Create Comment text object with IDSystem.out.println(\"Facility : \"+selectedValue);System.out.println(\"Hospital Readmission : \"+chkAdmissionFlag);System.out.println(\"Healthcare Program : \"+radioMedicaidText);System.out.println(\"Visit Date : \"+selectedDate);System.out.println(\"Comment : \"+inputtedComment);if (labelFacility.getText().equals(selectedValue) //Create condition for checking whether all displayed fields are identical with the inputted data &amp;&amp; labelReadmission.getText().equals(chkAdmissionFlag) &amp;&amp; labelProgram.getText().equals(radioMedicaidText) &amp;&amp; labelVisitDate.getText().equals(selectedDate) &amp;&amp; labelComment.getText().equals(inputtedComment)) { System.out.println(\"Test Passed!\");}else { System.out.println(\"Test Failed!\");}After the test finished, we close the browser.//Close browserdriver.close();Source code repository : Github" }, { "title": "Agile Software Development", "url": "/posts/agile-software-development/", "categories": "QA Knowledge, Agile Tester", "tags": "Learning", "date": "2022-02-15 19:05:00 +0800", "snippet": "The Fundamentals of Agile Software DevelopmentThe Agile ManifestoAgile Manifesto developed in 2001, it contains four statements of values: Individuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a planThe Agile Manifesto argues that although the concepts on the right have value, those on the left have greater value.Individuals and interactionsAgile development is very people-centered. Teams of people build software, and it is through continuous communication and interaction, rather than a reliance on tools or processes.Working SoftwareFrom a customer perspective, working software is much more useful and valuable than the overly detailed documentation and it provides and opportunity to give the development team rapid feedback, agile development can confer significant time-to-market advantage. Agile development is useful in rapidly changing business environments where the problems or solutions are unclear.Customer CollaborationCollaborating directly with the customer improves the likelihood of understanding exactly what the customer requires. While having contracts with customer may be important, working in regular and close collaboration with them is likely bring more success to the project.Responding to ChangeChange is inevitable in software projects. The environment in which the business operates, legislation, competitor activity, technology advances, and other factors must be accomodated by the development process. Having flexibility in work practices to embrace change is more important than simply adhering rigidly to a plan.PrinciplesThe core Agile Manifesto values are captured in twelve principles: Our highest priority is to satisfy the customer through early and continuous delivery of valuable Software. Welcome changing requirements, even late in development. Agile process harness change for the customer’s competitive advantage. Deliver working software frequently, at intervals of between few weeks to a few months, with a preference to the shorter timescale. Business people and developers must work together daily throughout the project. Build projects around motivated individuals. Give them the environment and support they need, and trust then to get the job done. The most efficient and effective method of conveying information to and within a development team is a face-to-face conversation. Working software is the primary measure of progress. Agile Processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely. Continuous attention to technical excellence and good design enhances agility. Simplicity is essential The best architectures, requirements, and designs emerge from self-organizing teams. At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behaviour accordinglyWhole-Team ApproachThe whole-team approach means involving everyone with the knowledge and skills necessary to ensure project success. The team includes representatives from the customer and other business stakeholders who determine product features. The team should be relatively small as few as three people and as many as nine. Ideally, the whole team shares the same workspace, as co-location strongly facilitates communication and interaction. The whole-team approach is supported through the daily stand-up meetings involving all members, where work progress is communicated and any impediments to progress are highlighted.Whole-team approach benefits in Agile development: Enhancing communication and collaboration within the team. Enabling the various skill sets within the team to be leveraged to the benefit of the projects Making quality everyone’s responsibilityThe whole team is responsible for quality in Agile projects. Testers will work closely with both developers and business representatives to ensure that the desired quality levels are achieved. This includes supporting and collaborating with business representatives to help them create suitable acceptance tests, working with developers to agree on the testing strategy, and deciding on test automation approaches.Early and Frequent FeedbackAgile projects have short iterations enabling the project team to receive early and continuous feedback on product quality throughout the development lifecycle. One way to provide rapid feedback is by continuous integration.When sequential development approach are used, the customer often does not see the product until the project is nearly completed. At that point, it is often too late for the development team to address any issue the customer may have. By getting frequent customer feedback, Agile teams can incorporate most new changes into product development process. Early and frequent feedback helps the team focus on the features with the highest business value, or associated risk, and these are delivered to the customer first.The Benefits of early and frequent feedback: Avoiding requirements misunderstandings, which may not have been detected until later in the development cycle when they are more expensive to fix. Clarifying customer feature requests, making them available for customer use early. This way, the product better reflects what the customer wants. Discovering (via continuous integration), isolating, and resolving quality problems early. Providing information to the Agile team regarding its productivity and ability to deliver. Promoting consistent project momentum.Aspects of Agile approachesThere are a number of Agile approaches in use by organizations. This subsection describes some of the agile approaches.Agile Software Development ApproachesExtreme ProgrammingOriginally introduced by Kent Beck, is an agile approach to software development described by certain values, principles, and development practices. XP embraces five values to guide development: Communication Simplicity Feedback Courage RespectXP describes a set of principles as additional guidelines: Humanity Economics Mutual benefit Self similarity improvement Diversity Reflection Flow Opportunity Redundancy Failure Quality Baby steps Accepted responsibilityXP describes thirteen primary practices: Sit together Whole team Informative workspace Energized work Pair programming Stories Weekly cycle Quarterly cycle Slack Ten-minute build Continuous integration Test first programming Incremental designScrumScrum is an Agile management framework which contains the following constituent instruments and practices: Sprint: Scrum divides a project into iterations (called sprints) of fixed length (usually 2-4 weeks). Product Increment: Each sprint results in a potentially releasable product. Product Backlog: Product owner manages a prioritized list of planned product items. The product backlog evolves from sprint to sprint (called backlog refinement). Sprint Backlog: At the start of each sprint, Scrum team selects a set of highest priority items from product backlog. Definition of Done: Defines appropriate criteria for sprint completion. Timeboxing: If the development team cannot finish a task within a sprint, the associated product features are removed from sprint and the task moved back into product backlog. Also applies for enforcing meeting start and end times. Transparency: The development team reports and updates sprint status on a daily basis at a meeting called daily scrum, it makes the progress of the sprint more visible to the team.Scrum defines three roles: Scrum Master: Ensures that Scrum practices and rules are implemented and followed, and resolves any violations, resource issues, or other impediments that could prevent the team from following the practices and rules. This person is not the team lead, but a coach. Product Owner: Represents the customer, and generates, maintains, prioritizes the product backlog. This person not the team lead. Development Team: Develop and test the product. The team is self-organized, there is no team lead, so the team makes the decisions.Scrum (as opposed to XP) does not dictate specific software development techniques (e.g., test first programming). In addition, Scrum does not provide guidance on how testing has to be done.KanbanKanban is a management approach that is sometimes used in Agile projects. The general objective is to visualize and optimize the flow of work within a value-added chain. Kanban utilizes three instruments: Kanban Board: The value chain to be managed is visualized by a Kanban board. Each column shows a station, which is a set of related activities, e.g., development or testing. The items to be produced or tasks to be processed are symbolized by tickets moving from left to right across the board through the stations. Work-in-Progress Limit: The amount of parallel active tasks is strictly limited. This is controlled by the maximum number of tickets allowed for a station for the board. Whenever a station has free capacity, the worker pulls a ticket from predecessor station. Lead Time: Kanban is used to optimize the continuous flow of tasks by minimizing the lead time for the complete value stream.Iterations or sprints are optional in Kanban. The Kanban process allows releasing its deliverables item by item, rather than as part of a release. Timeboxing as a synchronizing mechanism, therefore, is optional, unlike in scrum, which synchronizes all tasks within a sprint.Collaborative User Story CreationPoor specifications are often a major reason for project failure. Specification problems can result from the users lack of insight into their true needs, absence of a global vision for the system, redundant or contradictory features, and other miscommunications. In agile development, user stories are written to capture requirements from the perspectives of developers, testers, and business representatives. In sequential development, this shared vision of a feature is accomplished through formal reviews after requirement are written. In Agile development, this shared vision is accomplished through frequent informal reviews while the requirements are being written.The collaborative authorship of the user story can use techniques such as brainstorming and mind mapping. The tester may use the INVEST technique: Independent Negotiable valuable Estimable Small TestableAccording to the 3C concept, a user story is the conjuction of three elements: Card: The card is the physical media describing a user story. It identifies the requirement, its criticality, expected development and test duration, and the acceptance criteria for that story. Conversation: The conversation explains how the software will be used. The conversation can be documented or verbal. Conversations begins during the release-planning phase and continues when the story is scheduled. Confirmation: The acceptance criteria, discussed in the conversation, are used to confirm that the story is done. These acceptance criteria may span multiple user stories. Both positive and negative tests should be used to cover the criteriaRetrospectivesRetrospectives is a meeting held at the end of each iteration to discuss what was successful, what could be improved, and how to incorporate the improvements and retain the successes in future iterations.Retrospectives can result in test-related improvement decisions focused on test efectiveness, test productivity, test case quality, and team satisfaction. Root cause analysis of defects can drive testing and development improvements. In general, teams should implement only a few improvements per iteration. This allows for continuous improvement at a sustained pace.The timing and organization of the retrospective depends on the particular Agile method followed. Business representatives and the team attend each retrospective as participants while the facilitator organizes and runs the meeting. In some cases, the teams may invite other participants to the meeting.Continuous IntergrationDelivery of a product increment requires reliable, working, integrated software at the end of every sprint. Continuous integration addresses this challenge by merging all changes made to the software and integrating all changed components regularly, at least once a day. Since developers integrate their work constantly, build constantly, and test constantly, defects in code are detected more quickly.Continuous Integration process consists of the following automated activites: Static code analysis: executing static code analysis and reporting results Compile: compiling and linking the code, generating the executable files Unit test: executing unit tests, checking code coverage and reporting test results Deploy: installing the build into a test environment Integration test: executing the integration tests and reporting results Report (dashboard): posting the status of all these activities to a publicly visible location or e-mailing status to the teamAn automated build and test process takes place on a daily basis and detects integration errors early and quickly. Continuous integration allows Agile testers to run automated tests regularly, in some cases as part of the continuous integration process itself, and send quick feedback to the team on the quality of the code. Automated regression testing can be continuous throughout the iteration. Good automated regression tests cover as much functionality as possible, including user stories delivered in the previous iterations.Continuous integration can provide the following benefits: Allows earlier detection and easier root cause analysis of integration problems and conflicting changes Gives the development team regular feedback on whether the code is working Keeps the version of the software being tested within a day of the version being developed Reduces regression risk associated with developer code refactoring due to rapid re-testing of the code base after each small set of changes Provides confidence that each day’s development work is based on a solid foundation Makes progress toward the completion of the product increment visible, encouraging developers and testers Eliminates the schedule risks associated with big-bang integration Provides constant availability of executable software throughout the sprint for testing, demonstration, or education purposes Reduces repetitives manual testing activities Provides quick feedback on decisions made to improve quality and testersContinuous integration risks and challenge: Continuous Integration tools have to be introduces and maintained The continuous integration process must be defined and established Test automation requires additional resources and can be complex to established Thorough test coverage is essential to achieve automated testing advantages Teams sometimes over-rely on unit tests and perform too little system and acceptance testingRelease and Iteration PlanningRelease planning looks ahead to the release of a product, often a few months ahead of the start of a project. Release planning defines and re-defines the product backlog, and may involve refining larger user stories into a collection of smaller stories. Release planning provides the basis for a test approach and test plan spanning all iterations. Release plans are high-level.In release planning, business representatives establish and prioritize the user stories for the release, in collaboration with the team.Testers are involved in release planning and especially add value in the following activites: Defining testable user stories, including acceptance criteria Participating in project and quality risk analyses Estimating testing effort associated with the user stories Defining the necessary test levels Planning the testing for the releaseAfter release planning is done, iteration planning for the first iteration starts. Iteration planning looks ahead to the end of a single iteration and is concerned with the iteration backlog.In iteration planning, the team selects user stories from the prioritized release backlog, elaborates the user stories, performs a risk analysis for the user stories, and estimates the work needed for each user story. If a user story is too vague and attempts to clarify it have failed, the team can refuse to accept it and use the next user story based on priority. The business representatives must answer the team’s questions about each story so the team can understand what they should implement and how to test each story.The number of stories selected is based on established team velocity and the estimated size of the selected user stories. After the contents of the iteration are finalized, the user stories are broken into tasks, which will be carried out by the appropriate team members.Testers are involved in iteration planning and especially add value in the following activities: Participating in the detailed risk analysis of user stories Determining the testability of the user stories Creating acceptance tests for the user stories Breaking down user stories into tasks Estimating testing effort for all testing tasks Identifying functional and non-functional aspects of the system to be tested Supporting and participating in test automation at multiple levels of testingRelease and iteration planning should address test planning as well as planning for development activites. Particular test-related issues to address include: The scope of testing, the extent of testing for those areas in scope, the test goals, and the reasons for these decisions The team members who will carry out the test activities The test environment and test data needed The timing, sequencing, dependencies, and prerequisites for the functional and non-functional test activities The project and quality risks to be addressedThe Differences between Testing in Traditional and Agile ApproachesTesting and Development ActivitiesOne of the main differences between traditional lifecycles and Agile lifecycles is the idea of the very short iterations, each iteration resulting in working software that delivers features of value to business stakeholders. At the beginning of each iteration, there is an iteration planning period. Once iteration scope is established, the selected user stories are developed, integrated with the system, and tested. Testing activities occur throughout the iteration, not as a final activity.Testers, developers, and business stakeholders all have a role in testing, as with traditional lifecycles. Developers perform unit tests as they develop features from the user stories. Testers then test those features. Business stakeholders also test the stories during implementation, business stakeholders might use written test cases, but they also might simply experiment with and use the feature in order to provide fast feedback to the development team.The best practice is that no feature is considered done until it has been integrated and tested with the system. Another good practice is to address defects remaining from the previous iteration at the beginning of the next iteration, as part of the backlog for that iteration (referred to as “fix bugs first”). However, some complain that this practice results in a situation where the total work to be done in the iteration is unknown and it will be more difficult to estimate when the remaining features can be done.When risk-based testing is used as one of the test strategies, a high-level risk analysis occurs during release planning, with testers often driving that analysis. However, the specific quality risks associated with each iteration are identified and assessed in iteration planning. This risk analysis can influence the sequence of development as well as the priority and depth of testing for the features. It also influences the estimation of the test effort required for each feature.In some Agile practices (e.g., Extreme Programming), pairing is used. Pairing can involve testers working together in twos to test a feature. Pairing can also involve a tester working collaboratively with a developer to develop and test a feature. Pairing can be difficult when the test team is distributed, but processes and tools can help enable distributed pairing.Testers may also serve as testing and quality coaches within the team, sharing testing knowledge and supporting quality assurance work within the team. This promotes a sense of collective ownership of quality of the product.Test automation at all levels of testing occurs in many Agile teams, and this can mean that testers spend time creating, executing, monitoring, and maintaining automated tests and results. Because of the heavy use of test automation, a higher percentage of the manual testing on Agile projects tends to be done using experience-based and defect-based techniques such as software attacks, exploratory testing, and error guessing. While developers will focus on creating unit tests, testers should focus on creating automated integration, system, and system integration tests. This leads to a tendency for Agile teams to favor testers with a strong technical and test automation background.One core Agile principle is that change may occur throughout the project. Therefore, lightweight work product documentation is favored in Agile projects. Changes to existing features have testing implications, especially regression testing implications. The use of automated testing is one way of managing the amount of test effort associated with change. However, it’s important that the rate of change not exceed the project team’s ability to deal with the risks associated with those changes.Project Work ProductsProject work products of immediate interest to Agile testers typically fall into three categories: Business-oriented work products that describe what is needed (e.g., requirements specifications) and how to use it (e.g., user documentation) Development work products that describe how the system is built (e.g., database entity-relationship diagrams), that actually implement the system (e.g., code), or that evaluate individual pieces of code (e.g., automated unit tests) Test work products that describe how the system is tested (e.g., test strategies and plans), that actually test the system (e.g., manual and automated tests), or that present test results (e.g., test dashboards).In a typical Agile project, it is a common practice to avoid producing vast amounts of documentation. Instead, focus is more on having working software, together with automated tests that demonstrate conformance to requirements. This encouragement to reduce documentation applies only to documentation that does not deliver value to the customer.Typical business-oriented work products on Agile projects include user stories and acceptance criteria. User stories are the Agile form of requirements specifications, and should explain how the system should behave with respect to a single, coherent feature or function. A user story should define a feature small enough to be completed in a single iteration. Larger collections of related features, or a collection of sub-features that make up a single complex feature, may be referred to as “epics”. Epics may include user stories for different development teams. For example, one user story can describe what is required at the API-level (middleware) while another story describes what is needed at the UI- level (application). These collections may be developed over a series of sprints. Each epic and its user stories should have associated acceptance criteria.Typical developer work products on Agile projects include code. Agile developers also often create automated unit tests. These tests might be created after the development of code.Typical tester work products on Agile projects include automated tests, as well as documents such as test plans, quality risk catalogs, manual tests, defect reports, and test results logs. The documents are captured in as lightweight a fashion as possible, which is often also true of these documents in traditional lifecycles. Testers will also produce test metrics from defect reports and test results logs, and again there is an emphasis on a lightweight approach.In some Agile implementations, especially regulated, safety critical, distributed, or highly complex projects and products, further formalization of these work products is required. For example, some teams transform user stories and acceptance criteria into more formal requirements specifications. Vertical and horizontal traceability reports may be prepared to satisfy auditors, regulations, and other requirements." } ]
